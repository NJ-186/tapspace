<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Fractal Password - Tapspace Example</title>

  <!--
    Fractal password

    This example presents a novel password input method.
  -->

  <!-- Disable user scalability to override native touch gestures. -->
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <style>
    html, body, #space {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: white;
      color: black;
      font-family: sans-serif;
    }

    #heading {
      padding: 0 1em 0 1em;
    }
    #heading h1 {
      font-size: 2.62em;
      margin: 0.38em 0 0 0;
    }
    #heading p {
      font-size: 1em;
      margin: 0.25em 0 0 0;
      text-align: left;
      position: relative;
      left: 4em;
    }
    #heading a {
      color: black;
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div id="space"></div>

  <script src="../assets/ghoulog.js"></script>
  <script src="https://unpkg.com/tapspace@1.5.2/dist/tapspace.min.js"></script>

  <script>
    // Wrap in a function namespace. Easier to debug and no conflicts.
    (function () {
      var space = new tapspace.Space()
      var view = new tapspace.SpaceView(space)
      view.mount(document.getElementById('space'))

      // Shorthands
      const IVector = tapspace.geom.IVector
      const Vector = tapspace.geom.Vector

      var heading = new tapspace.SpaceHTML(
        '<div id="heading">' +
        '<h1>Fractal Password</h1>' +
        '<p>Zoom to the correct dot<br>and you are in.<br><br>' +
        'Powered by <a href="http://taataa.github.io/tapspace/">' +
        'Tapspace.js</a></p>' +
        '</div>'
      )
      // Place heading on
      heading.setParent(space)

      // Setup the view interaction
      var viewtouch = new tapspace.Touchable(view, view)
      var viewwheel = new tapspace.Wheelable(view, view)
      viewtouch.start({ translate: true, scale: true, rotate: true, tap: true })
      viewwheel.start({ scale: true })

      // viewtouch.on('gestureend', onGestureEnd)
      // viewwheel.on('wheel', onGestureEnd)
      //
      // // Tap to zoom in
      // viewtouch.on('tap', function (ev) {
      //   var itr = tapspace.geom.ITransform.IDENTITY
      //   itr = itr.scale(tapspace.geom.IVector.mean(ev.points), 1.6)
      //   onTransform(itr)
      // })

      const picWidth = 250
      var pic = {
        src: '../assets/go-stone-black.png',
        width: picWidth,
        height: picWidth
      }

      // Create recursively and fractal-like manner.
      // Each branch is given a directional vector.
      // The branch scales the vector appropriately.

      // // Create initial node
      // const root = new tapspace.SpaceImage(pic, space)
      // root.translate(
      //   [root.atMid()],
      //   [view.atMid()]
      // )

      // Place all nodes relative to the view mid.
      const createNode = (vec, scale) => {
        var si = new tapspace.SpaceImage(pic, space)
        var delta = new IVector(vec, space)
        si.scale(si.atMid(), scale)
        si.translate(
          [si.atMid()],
          [view.atMid().add(delta)]
        )
      }

      // // Create second depth level of nodes.
      // // Set child insertion points.
      // const w0 = 250
      // var Vector = tapspace.geom.Vector
      //
      // const rim1 = w0 / 2
      // const w1 = w0 * 0.618
      // const gap1 = w1 * 0.382
      // const d1 = rim1 + gap1 + w1 / 2
      // var spawns = [
      //   Vector.createFromPolar(d1, 0 * Math.PI / 6),
      //   Vector.createFromPolar(d1, 2 * Math.PI / 6),
      //   Vector.createFromPolar(d1, 4 * Math.PI / 6),
      //   Vector.createFromPolar(d1, 6 * Math.PI / 6),
      //   Vector.createFromPolar(d1, 8 * Math.PI / 6),
      //   Vector.createFromPolar(d1, 10 * Math.PI / 6)
      // ]

      const levels = [0, 1, 2, 3, 4, 5]
      // Create next level
      const initialConfig = {
        scale: 1,
        targets: [new Vector(0, 0)],
        directions: [new Vector(0, -1)]
      }
      levels.reduce((config, level) => {
        let newTargets = []
        let newDirections = []

        const w = config.scale * picWidth
        const ww = w * 0.618 // child image width

        config.targets.map((target, i) => {
          const direction = config.directions[i]

          // Create node here
          createNode(target, config.scale)

          // Create new targets
          const rim = w / 2
          const gap = ww * 0.382 // margin to previous
          const distance = rim + gap + ww / 2 // distance from mid to mid
          const r = direction.getRotation()

          // From parent to children:
          const spawnDirections = [
            Vector.createFromPolar(distance, r + 0 * Math.PI / 5),
            Vector.createFromPolar(distance, r + 2 * Math.PI / 5),
            Vector.createFromPolar(distance, r + 4 * Math.PI / 5),
            Vector.createFromPolar(distance, r + 6 * Math.PI / 5),
            Vector.createFromPolar(distance, r + 8 * Math.PI / 5)
          ]
          // From root to children:
          const childSpawns = spawnDirections.map(sd => target.add(sd))

          newTargets = newTargets.concat(childSpawns)
          newDirections = newDirections.concat(spawnDirections)
        })

        return {
          scale: config.scale * 0.382,
          targets: newTargets,
          directions: newDirections
        }
      }, initialConfig)

    })() // execute
  </script>
</body>
</html>
